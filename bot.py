# -*- coding: utf-8 -*-
# telegram.py  (aiogram 2.x)

import os
import asyncio
import logging
import sqlite3
from contextlib import closing
from datetime import datetime

import pytz
import jdatetime               # pip install jdatetime
from aiogram import Bot, Dispatcher, executor, types  # pip install aiogram==2.25.2
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove

from renew_service import MarzbanRenewService
from dotenv import load_dotenv

# Load environment variables from a .env file if present
load_dotenv()

# ---------------- ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ----------------
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
if not TELEGRAM_TOKEN:
    raise RuntimeError("TELEGRAM_TOKEN is not set in the environment")

def _ids_from_env(key: str):
    raw = os.getenv(key, "").strip()
    if not raw:
        return set()
    return {int(x) for x in raw.split(",") if x.strip().isdigit()}

SUPERADMINS = _ids_from_env("SUPERADMIN_IDS")  # ÿß⁄Øÿ± ÿÆÿßŸÑ€å ÿ®ÿßÿ¥ÿØÿå ÿ®Ÿàÿ™‚Äåÿßÿ≥ÿ™ÿ±Ÿæ ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™
ADMINS = _ids_from_env("ADMIN_IDS")

MARZBAN_ADDRESS = os.getenv("MARZBAN_ADDRESS")
MARZBAN_USERNAME = os.getenv("MARZBAN_USERNAME")
MARZBAN_PASSWORD = os.getenv("MARZBAN_PASSWORD")
if not all([MARZBAN_ADDRESS, MARZBAN_USERNAME, MARZBAN_PASSWORD]):
    raise RuntimeError("Marzban credentials are not fully set in the environment")

# Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπÿßŸÑ ÿ®ŸàÿØŸÜ ÿ±ÿ®ÿßÿ™ (on/off)
BOT_STATUS = os.getenv("BOT_STATUS", "on").lower() in ("on", "1", "true")

IR_TZ = pytz.timezone("Asia/Tehran")
DB_PATH = "/var/lib/marzban/renew-tg-bot/bot.db"

# ---------------- ŸÜŸÇÿ¥‚ÄåŸáÿß ----------------
def is_superadmin(tid: int) -> bool:
    return tid in SUPERADMINS or (len(SUPERADMINS) == 0)

def is_admin_db(tid: int) -> bool:
    with closing(sqlite3.connect(DB_PATH)) as conn:
        row = conn.execute("SELECT 1 FROM admins WHERE telegram_id=?", (tid,)).fetchone()
        return row is not None

def is_admin(tid: int) -> bool:
    return is_superadmin(tid) or is_admin_db(tid)

# ---------------- ÿØ€åÿ™ÿßÿ®€åÿ≥ ----------------
def init_db():
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        c = conn.cursor()
        c.execute("PRAGMA journal_mode=WAL;")
        c.execute("PRAGMA synchronous=NORMAL;")

        c.execute("CREATE TABLE IF NOT EXISTS admins (telegram_id INTEGER PRIMARY KEY)")
        c.execute(
            "CREATE TABLE IF NOT EXISTS customers (telegram_id INTEGER PRIMARY KEY, credits INTEGER NOT NULL DEFAULT 0, username TEXT, full_name TEXT)"
        )
        c.execute(
            """CREATE TABLE IF NOT EXISTS logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ts_utc TEXT NOT NULL,
            actor_id INTEGER NOT NULL,
            actor_username TEXT,
            target_marzban_username TEXT,
            success INTEGER NOT NULL,
            message TEXT
        )"""
        )
        # ŸÖŸáÿßÿ¨ÿ±ÿ™ ÿ¨ÿØŸàŸÑ admins ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ŸàÿØŸÜ username Ÿà full_name (ÿß⁄Øÿ± ŸÇÿ®ŸÑÿßŸã ŸÜÿ®ŸàÿØŸá)
        try:
            c.execute("ALTER TABLE admins ADD COLUMN username TEXT")
        except Exception:
            pass
        try:
            c.execute("ALTER TABLE admins ADD COLUMN full_name TEXT")
        except Exception:
            pass

        # ŸÖŸáÿßÿ¨ÿ±ÿ™ ÿ¨ÿØŸàŸÑ customers ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ŸàÿØŸÜ username Ÿà full_name (ÿß⁄Øÿ± ŸÇÿ®ŸÑÿßŸã ŸÜÿ®ŸàÿØŸá)
        try:
            c.execute("ALTER TABLE customers ADD COLUMN username TEXT")
        except Exception:
            pass
        try:
            c.execute("ALTER TABLE customers ADD COLUMN full_name TEXT")
        except Exception:
            pass

        for aid in ADMINS:
            c.execute("INSERT OR IGNORE INTO admins (telegram_id) VALUES (?)", (aid,))

def upsert_admin_profile(tid: int, username: str, full_name: str):
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.execute("""
            INSERT INTO admins (telegram_id, username, full_name)
            VALUES (?, ?, ?)
            ON CONFLICT(telegram_id) DO UPDATE SET
                username=excluded.username,
                full_name=excluded.full_name
        """, (tid, username or "", full_name or ""))

def add_admin(tid: int):
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.execute("INSERT OR IGNORE INTO admins (telegram_id) VALUES (?)", (tid,))

def remove_admin(tid: int):
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.execute("DELETE FROM admins WHERE telegram_id=?", (tid,))

def ensure_customer(tid: int, username: str | None = None, full_name: str | None = None):
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.execute("INSERT OR IGNORE INTO customers (telegram_id, credits) VALUES (?, 0)", (tid,))
        if username is not None or full_name is not None:
            conn.execute(
                "UPDATE customers SET username = COALESCE(?, username), full_name = COALESCE(?, full_name) WHERE telegram_id=?",
                (username, full_name, tid),
            )

def add_credits(tid: int, amount: int):
    ensure_customer(tid)
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.execute("UPDATE customers SET credits = credits + ? WHERE telegram_id=?", (amount, tid))

def set_credits(tid: int, amount: int):
    ensure_customer(tid)
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.execute("UPDATE customers SET credits = ? WHERE telegram_id=?", (amount, tid))

def get_credits(tid: int) -> int:
    ensure_customer(tid)
    with closing(sqlite3.connect(DB_PATH)) as conn:
        row = conn.execute("SELECT credits FROM customers WHERE telegram_id=?", (tid,)).fetchone()
        return int(row[0]) if row else 0

def dec_credit(tid: int) -> bool:
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        row = conn.execute("SELECT credits FROM customers WHERE telegram_id=?", (tid,)).fetchone()
        if not row or int(row[0]) <= 0:
            return False
        conn.execute("UPDATE customers SET credits = credits - 1 WHERE telegram_id=?", (tid,))
        return True

def log_action(actor_id: int, actor_username: str, marz_user: str, success: bool, message: str):
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.execute(
            "INSERT INTO logs (ts_utc, actor_id, actor_username, target_marzban_username, success, message) VALUES (?,?,?,?,?,?)",
            (datetime.utcnow().isoformat(), actor_id, actor_username, marz_user, 1 if success else 0, message)
        )

def jalali_now_str() -> str:
    now_teh = datetime.now(IR_TZ)
    jnow = jdatetime.datetime.fromgregorian(datetime=now_teh)
    return jnow.strftime("%Y/%m/%d - %H:%M:%S")

# ---------------- ⁄©€åÿ®Ÿàÿ±ÿØŸáÿß ----------------
def main_kb(is_admin_user: bool, is_super: bool) -> ReplyKeyboardMarkup:
    kb = ReplyKeyboardMarkup(resize_keyboard=True)
    kb.add(KeyboardButton("üîÅ ÿ™ŸÖÿØ€åÿØ ⁄©ÿßÿ±ÿ®ÿ±"))
    kb.add(KeyboardButton("üí≥ ÿßÿπÿ™ÿ®ÿßÿ± ŸÖŸÜ"))
    if is_admin_user:
        kb.add(KeyboardButton("üõ† ŸæŸÜŸÑ ÿßÿØŸÖ€åŸÜ"))
    kb.add(KeyboardButton("‚ÑπÔ∏è ÿ±ÿßŸáŸÜŸÖÿß"))
    return kb

def admin_kb(is_super: bool) -> ReplyKeyboardMarkup:
    kb = ReplyKeyboardMarkup(resize_keyboard=True)
    if is_super:
        kb.row(KeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ŸÖÿ¥ÿ™ÿ±€å"), KeyboardButton("üìå ÿ™ŸÜÿ∏€åŸÖ ÿßÿπÿ™ÿ®ÿßÿ±"))
        kb.row(KeyboardButton("‚ûï ÿ¥ÿßÿ±⁄ò ÿßÿπÿ™ÿ®ÿßÿ±"), KeyboardButton("üîÅ ÿ™ŸÖÿØ€åÿØ ÿ®ÿ±ÿß€å ŸÖÿ¥ÿ™ÿ±€å"))
        kb.row(KeyboardButton("üîé ÿßÿπÿ™ÿ®ÿßÿ± ŸÖÿ¥ÿ™ÿ±€å"), KeyboardButton("üëë ŸÖÿØ€åÿ±€åÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß"))
        kb.add(KeyboardButton("üë• ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß"))
        kb.add(KeyboardButton("üë• ŸÑ€åÿ≥ÿ™ ŸÖÿ¥ÿ™ÿ±€å‚ÄåŸáÿß"))
    else:
        # ÿßÿØŸÖ€åŸÜ ŸÖÿπŸÖŸàŸÑ€å ŸÅŸÇÿ∑ ÿπŸÖŸÑ€åÿßÿ™‚ÄåŸáÿß€å ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿß ÿ™ŸÖÿØ€åÿØ ÿ±ÿß ŸÖ€å‚Äåÿ®€åŸÜÿØ
        kb.row(KeyboardButton("üîÅ ÿ™ŸÖÿØ€åÿØ ÿ®ÿ±ÿß€å ŸÖÿ¥ÿ™ÿ±€å"), KeyboardButton("üîé ÿßÿπÿ™ÿ®ÿßÿ± ŸÖÿ¥ÿ™ÿ±€å"))
    kb.add(KeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™"))
    return kb

def admins_manage_kb() -> ReplyKeyboardMarkup:
    kb = ReplyKeyboardMarkup(resize_keyboard=True)
    kb.add(KeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿßÿØŸÖ€åŸÜ"), KeyboardButton("‚ûñ ÿ≠ÿ∞ŸÅ ÿßÿØŸÖ€åŸÜ"))
    kb.add(KeyboardButton("‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸæŸÜŸÑ ÿßÿØŸÖ€åŸÜ"))
    return kb

def cancel_kb() -> ReplyKeyboardMarkup:
    kb = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    kb.add(KeyboardButton("‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ"))
    return kb

# ---------------- FSM ----------------
class RenewFlow(StatesGroup):
    ask_username = State()

class AdminAddCustomerFlow(StatesGroup):
    ask_tid = State()

class AdminSetCreditsFlow(StatesGroup):
    ask_tid_amount = State()

class AdminAddCreditsFlow(StatesGroup):
    ask_tid_amount = State()

class AdminRenewForFlow(StatesGroup):
    ask_tid_username = State()

class AdminGetCreditsFlow(StatesGroup):
    ask_tid = State()

class AdminAddAdminFlow(StatesGroup):
    ask_tid = State()

class AdminRmAdminFlow(StatesGroup):
    ask_tid = State()

# ---------------- ÿ±ÿ®ÿßÿ™ ----------------
logging.basicConfig(level=logging.INFO)

bot = Bot(token=TELEGRAM_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

svc = MarzbanRenewService(MARZBAN_ADDRESS, MARZBAN_USERNAME, MARZBAN_PASSWORD)

async def notify_admins(text: str):
    targets = set()
    targets |= SUPERADMINS
    with closing(sqlite3.connect(DB_PATH)) as conn:
        rows = conn.execute("SELECT telegram_id FROM admins").fetchall()
        targets |= {int(r[0]) for r in rows}
    for tid in targets:
        try:
            await bot.send_message(chat_id=tid, text=text)
        except Exception:
            pass

def sync_admin_profile_if_needed(user: types.User):
    tid = user.id
    ensure_customer(tid, user.username or "", user.full_name or "")
    if is_admin(tid):
        upsert_admin_profile(tid, user.username or "", user.full_name or "")

# ---------------- ŸÅ€åŸÑÿ™ÿ± ÿØÿ≥ÿ™ÿ±ÿ≥€å ----------------
# ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÖÿπŸÖŸàŸÑ€å ⁄©Ÿá Ÿá€å⁄Ü ÿßÿπÿ™ÿ®ÿßÿ±€å ŸÜÿØÿßÿ±ŸÜÿØ Ÿæÿßÿ≥ÿÆ€å ÿßÿ±ÿ≥ÿßŸÑ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
# ÿ™ÿß ÿ®ÿØÿßŸÜŸÜÿØ ⁄Üÿ±ÿß ÿ®ÿßÿ™ ÿ®Ÿá Ÿæ€åÿßŸÖÿ¥ÿßŸÜ ÿ¨Ÿàÿßÿ® ŸÜŸÖ€å‚ÄåÿØŸáÿØ. ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß ÿßÿ≤ ÿß€åŸÜ
# ŸÅ€åŸÑÿ™ÿ± ŸÖÿ≥ÿ™ÿ´ŸÜÿß Ÿáÿ≥ÿ™ŸÜÿØ ÿ™ÿß ŸáŸÖ€åÿ¥Ÿá ÿØÿ≥ÿ™ÿ±ÿ≥€å ⁄©ÿßŸÖŸÑ ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ŸÜÿØ.
@dp.message_handler(
    lambda msg: not is_superadmin(msg.from_user.id) and get_credits(msg.from_user.id) <= 0,
    content_types=types.ContentTypes.ANY,
)
async def no_credit_reply(m: types.Message):
    sync_admin_profile_if_needed(m.from_user)
    await m.reply("ÿßÿπÿ™ÿ®ÿßÿ±€å ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ÿ®ÿßŸÇ€å ŸÜŸÖÿßŸÜÿØŸá ÿßÿ≥ÿ™")

# ---------------- ÿØÿ≥ÿ™Ÿàÿ±ÿßÿ™ ÿπŸÖŸàŸÖ€å ----------------
@dp.message_handler(commands=['whoami'])
async def whoami(m: types.Message):
    sync_admin_profile_if_needed(m.from_user)
    role = "ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ" if is_superadmin(m.from_user.id) else ("ÿßÿØŸÖ€åŸÜ" if is_admin(m.from_user.id) else "⁄©ÿßÿ±ÿ®ÿ±")
    await m.reply(f"ID: {m.from_user.id}\nŸÜŸÇÿ¥: {role}")

@dp.message_handler(commands=['start'])
async def start(m: types.Message, state: FSMContext):
    await state.finish()
    sync_admin_profile_if_needed(m.from_user)
    await m.reply(
        "ÿ≥ŸÑÿßŸÖ! ÿ®Ÿá ÿ±ÿ®ÿßÿ™ ÿ™ŸÖÿØ€åÿØ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ.",
        reply_markup=main_kb(is_admin(m.from_user.id), is_superadmin(m.from_user.id))
    )

@dp.message_handler(lambda msg: msg.text == "‚ÑπÔ∏è ÿ±ÿßŸáŸÜŸÖÿß")
async def help_btn(m: types.Message):
    sync_admin_profile_if_needed(m.from_user)
    await m.reply(
        "ÿ®ÿß ÿØ⁄©ŸÖŸá‚ÄåŸáÿß ⁄©ÿßÿ± ⁄©ŸÜ:\n"
        "üîÅ ¬´ÿ™ŸÖÿØ€åÿØ ⁄©ÿßÿ±ÿ®ÿ±¬ª ‚Üí ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ÿ±ÿß ŸÖ€å‚Äå⁄Ø€åÿ±ÿØ Ÿà ÿ™ŸÖÿØ€åÿØ €≥€±ÿ±Ÿàÿ≤Ÿá ÿßŸÜÿ¨ÿßŸÖ ŸÖ€å‚ÄåÿØŸáÿØ.\n"
        "üí≥ ¬´ÿßÿπÿ™ÿ®ÿßÿ± ŸÖŸÜ¬ª ‚Üí ÿ™ÿπÿØÿßÿØ ÿ™ŸÖÿØ€åÿØŸáÿß€å ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá ÿ±ÿß ŸÜÿ¥ÿßŸÜ ŸÖ€å‚ÄåÿØŸáÿØ.\n"
        "üõ† ¬´ŸæŸÜŸÑ ÿßÿØŸÖ€åŸÜ¬ª ‚Üí ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß."
    )

@dp.message_handler(lambda msg: msg.text == "üí≥ ÿßÿπÿ™ÿ®ÿßÿ± ŸÖŸÜ")
async def my_credits_btn(m: types.Message):
    sync_admin_profile_if_needed(m.from_user)
    cr = get_credits(m.from_user.id)
    await m.reply(f"ÿßÿπÿ™ÿ®ÿßÿ± ÿ™ŸÖÿØ€åÿØ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá: {cr}")

# ---------------- ÿßŸÜÿµÿ±ÿßŸÅ ÿ≥ÿ±ÿßÿ≥ÿ±€å (ÿ®ÿ±ÿß€å ŸáŸÖŸá ŸÖÿ±ÿßÿ≠ŸÑ) ----------------
@dp.message_handler(lambda msg: msg.text == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ", state='*')
async def cancel_any(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    current = await state.get_state()
    if current is not None:
        await state.finish()
    await m.reply("ŸÑÿ∫Ÿà ÿ¥ÿØ.", reply_markup=main_kb(is_admin(m.from_user.id), is_superadmin(m.from_user.id)))

# ---------------- ÿ™ŸÖÿØ€åÿØ ⁄©ÿßÿ±ÿ®ÿ± ----------------
@dp.message_handler(lambda msg: msg.text == "üîÅ ÿ™ŸÖÿØ€åÿØ ⁄©ÿßÿ±ÿ®ÿ±")
async def renew_btn(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    cr = get_credits(m.from_user.id)
    if cr <= 0:
        return await m.reply("ÿßÿπÿ™ÿ®ÿßÿ±€å ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ÿ®ÿßŸÇ€å ŸÜŸÖÿßŸÜÿØŸá ÿßÿ≥ÿ™")
    await RenewFlow.ask_username.set()
    await m.reply("ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ:", reply_markup=cancel_kb())

@dp.message_handler(state=RenewFlow.ask_username)
async def renew_get_username(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    username = (m.text or "").strip()
    if not username or username == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return  # ŸáŸÜÿØŸÑÿ± ÿßŸÜÿµÿ±ÿßŸÅ ÿ¨ÿØÿßÿ≥ÿ™
    ok = False
    msg = ""
    try:
        result = await svc.renew_user_31d(username)
        ok = bool(result.get("ok"))
        msg = result.get("message", "")
    except Exception as e:
        ok = False
        msg = f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿß ÿ≥ÿ±Ÿàÿ±: {e}"
    if ok:
        if not dec_credit(m.from_user.id):
            await state.finish()
            return await m.reply(
                "ÿßÿπÿ™ÿ®ÿßÿ± ÿ¥ŸÖÿß ⁄©ÿßŸÅ€å ŸÜÿ®ŸàÿØ.",
                reply_markup=main_kb(is_admin(m.from_user.id), is_superadmin(m.from_user.id))
            )
        await m.reply(
            "‚úÖ ÿ™ŸÖÿØ€åÿØ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ. (€≥€± ÿ±Ÿàÿ≤Ÿá + ÿ±€åÿ≥ÿ™ ÿ≠ÿ¨ŸÖ + ÿß⁄©ÿ™€åŸà)",
            reply_markup=main_kb(is_admin(m.from_user.id), is_superadmin(m.from_user.id))
        )
    else:
        await m.reply(
            f"‚ùå {msg or 'ÿ™ŸÖÿØ€åÿØ ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.'}",
            reply_markup=main_kb(is_admin(m.from_user.id), is_superadmin(m.from_user.id))
        )
    stamp = jalali_now_str()
    actor = f"{m.from_user.id} ({m.from_user.full_name or ''})"
    report = (f"üßæ ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ™ŸÖÿØ€åÿØ ({stamp})\n"
              f"⁄©ÿßÿ±ÿ®ÿ± ÿ™ŸÑ⁄Øÿ±ÿßŸÖ: {actor}\n"
              f"ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å: {username}\n"
              f"ŸÜÿ™€åÿ¨Ÿá: {'ŸÖŸàŸÅŸÇ' if ok else 'ŸÜÿßŸÖŸàŸÅŸÇ'}\n"
              f"Ÿæ€åÿßŸÖ: {msg}")
    log_action(m.from_user.id, m.from_user.username or "", username, ok, msg)
    await notify_admins(report)
    await state.finish()

# ---------------- ŸæŸÜŸÑ ÿßÿØŸÖ€åŸÜ ----------------
@dp.message_handler(lambda msg: msg.text == "üõ† ŸæŸÜŸÑ ÿßÿØŸÖ€åŸÜ")
async def admin_panel(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_admin(m.from_user.id):
        return await m.reply(
            "ÿØÿ≥ÿ™ÿ±ÿ≥€å ⁄©ÿßŸÅ€å ŸÜÿØÿßÿ±€å.",
            reply_markup=main_kb(is_admin(m.from_user.id), is_superadmin(m.from_user.id))
        )
    await state.finish()
    await m.reply(
        "ŸæŸÜŸÑ ÿßÿØŸÖ€åŸÜ:",
        reply_markup=admin_kb(is_superadmin(m.from_user.id))
    )

@dp.message_handler(lambda msg: msg.text == "‚¨ÖÔ∏è ÿ®ÿßÿ≤⁄Øÿ¥ÿ™")
async def back_to_main(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    await state.finish()
    await m.reply(
        "ŸÖŸÜŸà€å ÿßÿµŸÑ€å:",
        reply_markup=main_kb(is_admin(m.from_user.id), is_superadmin(m.from_user.id))
    )

# ---- ÿßŸÅÿ≤ŸàÿØŸÜ ŸÖÿ¥ÿ™ÿ±€å (ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ŸÖÿ¥ÿ™ÿ±€å")
async def admin_add_customer(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.", reply_markup=admin_kb(False))
    await AdminAddCustomerFlow.ask_tid.set()
    await m.reply("ÿ¢€åÿØ€å ÿπÿØÿØ€å ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ŸÖÿ¥ÿ™ÿ±€å ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ:", reply_markup=cancel_kb())

@dp.message_handler(state=AdminAddCustomerFlow.ask_tid)
async def admin_add_customer_tid(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if (m.text or "") == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return
    if not (m.text or "").isdigit():
        return await m.reply("€å⁄© ÿ¢€åÿØ€å ÿπÿØÿØ€å ŸÖÿπÿ™ÿ®ÿ± ÿ®ŸÅÿ±ÿ≥ÿ™.", reply_markup=cancel_kb())
    tid = int(m.text.strip())
    ensure_customer(tid)
    await m.reply(f"ŸÖÿ¥ÿ™ÿ±€å {tid} ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.", reply_markup=admin_kb(is_superadmin(m.from_user.id)))
    await state.finish()

# ---- ÿ™ŸÜÿ∏€åŸÖ ÿßÿπÿ™ÿ®ÿßÿ± (ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "üìå ÿ™ŸÜÿ∏€åŸÖ ÿßÿπÿ™ÿ®ÿßÿ±")
async def admin_setcredits(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.", reply_markup=admin_kb(False))
    await AdminSetCreditsFlow.ask_tid_amount.set()
    await m.reply("ŸÅÿ±ŸÖÿ™: <telegram_id> <n>\nŸÖÿ´ÿßŸÑ: 12345678 20", reply_markup=cancel_kb())

@dp.message_handler(state=AdminSetCreditsFlow.ask_tid_amount)
async def admin_setcredits_args(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if (m.text or "") == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return
    try:
        tid_s, amt_s = (m.text or "").split()
        set_credits(int(tid_s), int(amt_s))
        await m.reply(
            f"ÿßÿπÿ™ÿ®ÿßÿ± ŸÖÿ¥ÿ™ÿ±€å {tid_s} ÿ®Ÿá {amt_s} ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ.",
            reply_markup=admin_kb(is_superadmin(m.from_user.id))
        )
        await state.finish()
    except Exception:
        await m.reply("ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™ ŸÜ€åÿ≥ÿ™. ÿØŸàÿ®ÿßÿ±Ÿá ÿ®ŸÅÿ±ÿ≥ÿ™: <telegram_id> <n>", reply_markup=cancel_kb())

# ---- ÿ¥ÿßÿ±⁄ò ÿßÿπÿ™ÿ®ÿßÿ± (ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "‚ûï ÿ¥ÿßÿ±⁄ò ÿßÿπÿ™ÿ®ÿßÿ±")
async def admin_addcredits(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.", reply_markup=admin_kb(False))
    await AdminAddCreditsFlow.ask_tid_amount.set()
    await m.reply("ŸÅÿ±ŸÖÿ™: <telegram_id> <n>\nŸÖÿ´ÿßŸÑ: 12345678 10", reply_markup=cancel_kb())

@dp.message_handler(state=AdminAddCreditsFlow.ask_tid_amount)
async def admin_addcredits_args(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if (m.text or "") == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return
    try:
        tid_s, amt_s = (m.text or "").split()
        add_credits(int(tid_s), int(amt_s))
        await m.reply(
            f"{amt_s} Ÿàÿßÿ≠ÿØ ÿßÿπÿ™ÿ®ÿßÿ± ÿ®Ÿá ŸÖÿ¥ÿ™ÿ±€å {tid_s} ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ.",
            reply_markup=admin_kb(is_superadmin(m.from_user.id))
        )
        await state.finish()
    except Exception:
        await m.reply("ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™ ŸÜ€åÿ≥ÿ™. ÿØŸàÿ®ÿßÿ±Ÿá ÿ®ŸÅÿ±ÿ≥ÿ™: <telegram_id> <n>", reply_markup=cancel_kb())

# ---- ÿ™ŸÖÿØ€åÿØ ÿ®ÿ±ÿß€å ŸÖÿ¥ÿ™ÿ±€å (ÿßÿØŸÖ€åŸÜ Ÿà ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "üîÅ ÿ™ŸÖÿØ€åÿØ ÿ®ÿ±ÿß€å ŸÖÿ¥ÿ™ÿ±€å")
async def admin_renew_for(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_admin(m.from_user.id):
        return await m.reply("ÿØÿ≥ÿ™ÿ±ÿ≥€å ⁄©ÿßŸÅ€å ŸÜÿØÿßÿ±€å.")
    await AdminRenewForFlow.ask_tid_username.set()
    await m.reply("ŸÅÿ±ŸÖÿ™: <telegram_id> <username>\nŸÖÿ´ÿßŸÑ: 12345678 myuser", reply_markup=cancel_kb())

@dp.message_handler(state=AdminRenewForFlow.ask_tid_username)
async def admin_renew_for_args(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if (m.text or "") == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return
    try:
        tid_s, username = (m.text or "").split(maxsplit=1)
        tid = int(tid_s)
    except Exception:
        return await m.reply("ŸÅÿ±ŸÖÿ™ ÿØÿ±ÿ≥ÿ™ ŸÜ€åÿ≥ÿ™. ÿØŸàÿ®ÿßÿ±Ÿá ÿ®ŸÅÿ±ÿ≥ÿ™: <telegram_id> <username>", reply_markup=cancel_kb())
    credits = get_credits(tid)
    if credits <= 0:
        await state.finish()
        return await m.reply("ÿßÿπÿ™ÿ®ÿßÿ± ŸÖÿ¥ÿ™ÿ±€å ÿµŸÅÿ± ÿßÿ≥ÿ™.", reply_markup=admin_kb(is_superadmin(m.from_user.id)))

    ok = False
    msg = ""
    try:
        result = await svc.renew_user_31d(username.strip())
        ok = bool(result.get("ok"))
        msg = result.get("message", "")
    except Exception as e:
        ok = False
        msg = f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿß ÿ≥ÿ±Ÿàÿ±: {e}"

    if ok:
        if not dec_credit(tid):
            await m.reply("ÿßÿπÿ™ÿ®ÿßÿ± ŸÖÿ¥ÿ™ÿ±€å ⁄©ÿßŸÅ€å ŸÜÿ®ŸàÿØ (Race).", reply_markup=admin_kb(is_superadmin(m.from_user.id)))
        else:
            await m.reply(f"‚úÖ ÿ™ŸÖÿØ€åÿØ ÿ®ÿ±ÿß€å {tid} ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ.", reply_markup=admin_kb(is_superadmin(m.from_user.id)))
    else:
        await m.reply(f"‚ùå {msg or 'ÿ™ŸÖÿØ€åÿØ ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.'}", reply_markup=admin_kb(is_superadmin(m.from_user.id)))

    stamp = jalali_now_str()
    actor = f"{m.from_user.id} ({m.from_user.full_name or ''})"
    report = (f"üßæ ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ™ŸÖÿØ€åÿØ ({stamp})\n"
              f"ÿßÿØŸÖ€åŸÜ: {actor}\n"
              f"ÿ®ÿ±ÿß€å ŸÖÿ¥ÿ™ÿ±€å: {tid}\n"
              f"ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å: {username}\n"
              f"ŸÜÿ™€åÿ¨Ÿá: {'ŸÖŸàŸÅŸÇ' if ok else 'ŸÜÿßŸÖŸàŸÅŸÇ'}\n"
              f"Ÿæ€åÿßŸÖ: {msg}")
    log_action(m.from_user.id, m.from_user.username or "", username, ok, msg)
    await notify_admins(report)
    await state.finish()

# ---- ÿßÿπÿ™ÿ®ÿßÿ± ŸÖÿ¥ÿ™ÿ±€å (ÿßÿØŸÖ€åŸÜ Ÿà ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "üîé ÿßÿπÿ™ÿ®ÿßÿ± ŸÖÿ¥ÿ™ÿ±€å")
async def admin_getcredits(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_admin(m.from_user.id):
        return await m.reply("ÿØÿ≥ÿ™ÿ±ÿ≥€å ⁄©ÿßŸÅ€å ŸÜÿØÿßÿ±€å.")
    await AdminGetCreditsFlow.ask_tid.set()
    await m.reply("ÿ¢€åÿØ€å ÿπÿØÿØ€å ŸÖÿ¥ÿ™ÿ±€å ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™:", reply_markup=cancel_kb())

@dp.message_handler(state=AdminGetCreditsFlow.ask_tid)
async def admin_getcredits_tid(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if (m.text or "") == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return
    if not (m.text or "").isdigit():
        return await m.reply("€å⁄© ÿ¢€åÿØ€å ÿπÿØÿØ€å ŸÖÿπÿ™ÿ®ÿ± ÿ®ŸÅÿ±ÿ≥ÿ™.", reply_markup=cancel_kb())
    tid = int(m.text.strip())
    cr = get_credits(tid)
    await m.reply(f"ÿßÿπÿ™ÿ®ÿßÿ± ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸáŸî ŸÖÿ¥ÿ™ÿ±€å {tid}: {cr}", reply_markup=admin_kb(is_superadmin(m.from_user.id)))
    await state.finish()

# ---- ŸÖÿØ€åÿ±€åÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß (ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "üëë ŸÖÿØ€åÿ±€åÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß")
async def admins_manage(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.")
    await m.reply("ŸÖÿØ€åÿ±€åÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß:", reply_markup=admins_manage_kb())

@dp.message_handler(lambda msg: msg.text == "‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿßÿØŸÖ€åŸÜ")
async def admins_add_btn(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.")
    await AdminAddAdminFlow.ask_tid.set()
    await m.reply("ÿ¢€åÿØ€å ÿπÿØÿØ€å ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ÿßÿØŸÖ€åŸÜ ÿ¨ÿØ€åÿØ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™:", reply_markup=cancel_kb())

@dp.message_handler(state=AdminAddAdminFlow.ask_tid)
async def admins_add_tid(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if (m.text or "") == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return
    if not (m.text or "").isdigit():
        return await m.reply("€å⁄© ÿ¢€åÿØ€å ÿπÿØÿØ€å ŸÖÿπÿ™ÿ®ÿ± ÿ®ŸÅÿ±ÿ≥ÿ™.", reply_markup=cancel_kb())
    tid = int(m.text.strip())
    add_admin(tid)
    await m.reply(f"ÿßÿØŸÖ€åŸÜ {tid} ÿßŸÅÿ≤ŸàÿØŸá ÿ¥ÿØ.", reply_markup=admins_manage_kb())
    await state.finish()

@dp.message_handler(lambda msg: msg.text == "‚ûñ ÿ≠ÿ∞ŸÅ ÿßÿØŸÖ€åŸÜ")
async def admins_rm_btn(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.")
    await AdminRmAdminFlow.ask_tid.set()
    await m.reply("ÿ¢€åÿØ€å ÿπÿØÿØ€å ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ÿßÿØŸÖ€åŸÜ€å ⁄©Ÿá ÿ®ÿß€åÿØ ÿ≠ÿ∞ŸÅ ÿ¥ŸàÿØ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™:", reply_markup=cancel_kb())

@dp.message_handler(state=AdminRmAdminFlow.ask_tid)
async def admins_rm_tid(m: types.Message, state: FSMContext):
    sync_admin_profile_if_needed(m.from_user)
    if (m.text or "") == "‚¨ÖÔ∏è ÿßŸÜÿµÿ±ÿßŸÅ":
        return
    if not (m.text or "").isdigit():
        return await m.reply("€å⁄© ÿ¢€åÿØ€å ÿπÿØÿØ€å ŸÖÿπÿ™ÿ®ÿ± ÿ®ŸÅÿ±ÿ≥ÿ™.", reply_markup=cancel_kb())
    tid = int(m.text.strip())
    remove_admin(tid)
    await m.reply(f"ÿßÿØŸÖ€åŸÜ {tid} ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.", reply_markup=admins_manage_kb())
    await state.finish()

# ---- ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß (ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "üë• ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß")
async def admins_list(m: types.Message):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.")
    with closing(sqlite3.connect(DB_PATH)) as conn:
        rows = conn.execute("SELECT telegram_id, COALESCE(username,''), COALESCE(full_name,'') FROM admins ORDER BY telegram_id").fetchall()
    if not rows:
        return await m.reply("Ÿá€å⁄Ü ÿßÿØŸÖ€åŸÜ€å ÿØÿ± ÿ≥€åÿ≥ÿ™ŸÖ ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™.")
    lines = []
    for tid, uname, fname in rows:
        tag = f"@{uname}" if uname else "(ÿ®ÿØŸàŸÜ €åŸàÿ≤ÿ±ŸÜ€åŸÖ)"
        name = f" - {fname}" if fname else ""
        lines.append(f"‚Ä¢ {tid}  {tag}{name}")
    await m.reply("ŸÑ€åÿ≥ÿ™ ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß:\n" + "\n".join(lines))

# ---- ŸÑ€åÿ≥ÿ™ ŸÖÿ¥ÿ™ÿ±€å‚ÄåŸáÿß (ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ)
@dp.message_handler(lambda msg: msg.text == "üë• ŸÑ€åÿ≥ÿ™ ŸÖÿ¥ÿ™ÿ±€å‚ÄåŸáÿß")
async def customers_list(m: types.Message):
    sync_admin_profile_if_needed(m.from_user)
    if not is_superadmin(m.from_user.id):
        return await m.reply("ŸÅŸÇÿ∑ ÿ≥ŸàŸæÿ±ÿßÿØŸÖ€åŸÜ.")
    with closing(sqlite3.connect(DB_PATH)) as conn:
        rows = conn.execute(
            "SELECT telegram_id, COALESCE(username,''), COALESCE(full_name,''), credits FROM customers ORDER BY telegram_id"
        ).fetchall()
    if not rows:
        return await m.reply("Ÿá€å⁄Ü ŸÖÿ¥ÿ™ÿ±€å‚Äåÿß€å ÿØÿ± ÿ≥€åÿ≥ÿ™ŸÖ ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™.")
    lines = []
    for tid, uname, fname, credits in rows:
        if not uname or not fname:
            try:
                chat = await bot.get_chat(tid)
                uname = uname or (chat.username or "")
                fname = fname or (chat.full_name or "")
                ensure_customer(tid, uname or "", fname or "")
            except Exception:
                pass
        tag = f"@{uname}" if uname else "(ÿ®ÿØŸàŸÜ €åŸàÿ≤ÿ±ŸÜ€åŸÖ)"
        name = f" - {fname}" if fname else ""
        lines.append(f"‚Ä¢ {tid}  {tag}{name} - ÿßÿπÿ™ÿ®ÿßÿ±: {credits}")
    await m.reply("ŸÑ€åÿ≥ÿ™ ŸÖÿ¥ÿ™ÿ±€å‚ÄåŸáÿß:\n" + "\n".join(lines))

# ---------------- ÿßÿ¨ÿ±ÿß ----------------
if __name__ == "__main__":
    init_db()
    if not BOT_STATUS:
        print("Bot status is off. Exiting.")
    else:
        try:
            executor.start_polling(dp, skip_updates=True)
        finally:
            loop = asyncio.get_event_loop()
            loop.run_until_complete(svc.close())
